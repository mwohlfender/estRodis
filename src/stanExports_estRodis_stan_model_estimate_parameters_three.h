// Generated by rstantools.  Do not edit by hand.

/*
    estRodis is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    estRodis is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with estRodis.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model_estRodis_stan_model_estimate_parameters_three_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 83> locations_array__ =
  {" (found before start of program)",
  " (in 'string', line 175, column 2 to column 23)",
  " (in 'string', line 176, column 2 to column 23)",
  " (in 'string', line 177, column 2 to column 75)",
  " (in 'string', line 180, column 2 to column 58)",
  " (in 'string', line 185, column 2 to column 36)",
  " (in 'string', line 187, column 2 to column 36)",
  " (in 'string', line 189, column 2 to column 116)",
  " (in 'string', line 191, column 2 to column 110)",
  " (in 'string', line 157, column 2 to column 22)",
  " (in 'string', line 159, column 20 to column 21)",
  " (in 'string', line 159, column 2 to column 23)",
  " (in 'string', line 161, column 20 to column 21)",
  " (in 'string', line 161, column 2 to column 23)",
  " (in 'string', line 163, column 2 to column 18)",
  " (in 'string', line 165, column 2 to column 18)",
  " (in 'string', line 167, column 2 to column 22)",
  " (in 'string', line 170, column 2 to column 24)",
  " (in 'string', line 172, column 2 to column 24)",
  " (in 'string', line 9, column 4 to column 20)",
  " (in 'string', line 13, column 6 to column 133)",
  " (in 'string', line 11, column 27 to line 15, column 5)",
  " (in 'string', line 11, column 4 to line 15, column 5)",
  " (in 'string', line 17, column 4 to column 19)",
  " (in 'string', line 7, column 85 to line 19, column 3)",
  " (in 'string', line 25, column 4 to column 19)",
  " (in 'string', line 33, column 25 to column 37)",
  " (in 'string', line 33, column 6 to column 37)",
  " (in 'string', line 31, column 11 to line 35, column 5)",
  " (in 'string', line 29, column 6 to column 20)",
  " (in 'string', line 27, column 19 to line 31, column 5)",
  " (in 'string', line 27, column 4 to line 35, column 5)",
  " (in 'string', line 37, column 4 to column 19)",
  " (in 'string', line 23, column 39 to line 39, column 3)",
  " (in 'string', line 52, column 4 to column 54)",
  " (in 'string', line 55, column 4 to column 153)",
  " (in 'string', line 58, column 4 to column 18)",
  " (in 'string', line 61, column 4 to column 55)",
  " (in 'string', line 64, column 4 to column 65)",
  " (in 'string', line 67, column 4 to column 29)",
  " (in 'string', line 70, column 4 to column 33)",
  " (in 'string', line 73, column 4 to column 58)",
  " (in 'string', line 76, column 18 to column 62)",
  " (in 'string', line 76, column 4 to column 127)",
  " (in 'string', line 79, column 21 to column 65)",
  " (in 'string', line 79, column 4 to column 135)",
  " (in 'string', line 82, column 42 to column 86)",
  " (in 'string', line 82, column 4 to column 156)",
  " (in 'string', line 85, column 54 to column 73)",
  " (in 'string', line 85, column 4 to column 119)",
  " (in 'string', line 88, column 52 to column 67)",
  " (in 'string', line 88, column 4 to column 108)",
  " (in 'string', line 91, column 20 to column 35)",
  " (in 'string', line 91, column 4 to column 76)",
  " (in 'string', line 97, column 6 to column 156)",
  " (in 'string', line 94, column 62 to line 99, column 5)",
  " (in 'string', line 94, column 4 to line 99, column 5)",
  " (in 'string', line 108, column 6 to column 49)",
  " (in 'string', line 111, column 6 to column 57)",
  " (in 'string', line 114, column 65 to column 106)",
  " (in 'string', line 114, column 6 to column 106)",
  " (in 'string', line 117, column 65 to column 149)",
  " (in 'string', line 117, column 6 to column 149)",
  " (in 'string', line 119, column 6 to column 81)",
  " (in 'string', line 122, column 6 to line 134, column 7)",
  " (in 'string', line 125, column 8 to column 88)",
  " (in 'string', line 127, column 68 to column 242)",
  " (in 'string', line 127, column 8 to column 242)",
  " (in 'string', line 130, column 8 to column 143)",
  " (in 'string', line 132, column 8 to column 19)",
  " (in 'string', line 137, column 6 to column 119)",
  " (in 'string', line 140, column 36 to column 188)",
  " (in 'string', line 140, column 6 to column 188)",
  " (in 'string', line 105, column 11 to line 142, column 5)",
  " (in 'string', line 103, column 36 to column 137)",
  " (in 'string', line 103, column 6 to column 137)",
  " (in 'string', line 101, column 32 to line 105, column 5)",
  " (in 'string', line 101, column 4 to line 142, column 5)",
  " (in 'string', line 146, column 6 to column 90)",
  " (in 'string', line 144, column 34 to line 148, column 5)",
  " (in 'string', line 144, column 4 to line 148, column 5)",
  " (in 'string', line 150, column 4 to column 28)",
  " (in 'string', line 49, column 137 to line 152, column 3)"};
template <bool propto__, typename T0__, typename T1__, typename T2__,
          typename T3__, typename T4__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>>* = nullptr>
stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>
estRodis_stan_scaled_beta_lpdf(const T0__& alpha, const T1__& beta,
                               const T2__& p, const T3__& q, const T4__& x,
                               std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>* = nullptr>
int determine_scaling_factor(const T0__& x, std::ostream* pstream__);
template <bool propto__, typename T2__, typename T3__, typename T4__,
          typename T5__,
          stan::require_all_t<stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T5__>>* = nullptr>
stan::promote_args_t<T2__, T3__, T4__, T5__>
estRodis_stan_likelihood_log(const std::vector<int>& clusters_size,
                             const std::vector<int>& clusters_freq,
                             const T2__& R, const T3__& k, const T4__&
                             mutation_proba, const T5__& detection_proba,
                             std::ostream* pstream__);
template <bool propto__, typename T0__, typename T1__, typename T2__,
          typename T3__, typename T4__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>>*>
stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>
estRodis_stan_scaled_beta_lpdf(const T0__& alpha, const T1__& beta,
                               const T2__& p, const T3__& q, const T4__& x,
                               std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ result = DUMMY_VAR__;
    current_statement__ = 19;
    result = 0;
    current_statement__ = 22;
    if ((stan::math::primitive_value(stan::math::logical_gte(x, p)) &&
        stan::math::primitive_value(stan::math::logical_lte(x, q)))) {
      current_statement__ = 20;
      result = ((stan::math::pow((x - p), (alpha - 1)) *
        stan::math::pow((q - x), (beta - 1))) /
        (((stan::math::pow((q - p), ((alpha + beta) - 1)) *
        stan::math::tgamma(alpha)) * stan::math::tgamma(beta)) /
        stan::math::tgamma((alpha + beta))));
    }
    current_statement__ = 23;
    return result;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, stan::require_all_t<stan::is_stan_scalar<T0__>>*>
int determine_scaling_factor(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int result = std::numeric_limits<int>::min();
    current_statement__ = 25;
    result = 0;
    current_statement__ = 31;
    if (stan::math::logical_gte(x, 1000)) {
      current_statement__ = 29;
      result = 1000;
    } else {
      current_statement__ = 27;
      while (stan::math::logical_lt(result, x)) {
        current_statement__ = 26;
        result = (result + 1);
      }
    }
    current_statement__ = 32;
    return result;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <bool propto__, typename T2__, typename T3__, typename T4__,
          typename T5__,
          stan::require_all_t<stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>,
                              stan::is_stan_scalar<T5__>>*>
stan::promote_args_t<T2__, T3__, T4__, T5__>
estRodis_stan_likelihood_log(const std::vector<int>& clusters_size,
                             const std::vector<int>& clusters_freq,
                             const T2__& R, const T3__& k, const T4__&
                             mutation_proba, const T5__& detection_proba,
                             std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T2__, T3__, T4__, T5__>;
  int current_statement__ = 0;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int n_clusters_size = std::numeric_limits<int>::min();
    current_statement__ = 34;
    n_clusters_size = stan::math::num_elements(clusters_size);
    int upper_limit_size_identical_sequence_clusters =
      std::numeric_limits<int>::min();
    current_statement__ = 35;
    upper_limit_size_identical_sequence_clusters = stan::math::max(
                                                     (determine_scaling_factor(
                                                        (2 /
                                                        detection_proba),
                                                        pstream__) *
                                                     stan::math::max(
                                                       clusters_size)),
                                                     (stan::math::max(
                                                        clusters_size) + 500));
    int index = std::numeric_limits<int>::min();
    current_statement__ = 36;
    index = 2;
    local_scalar_t__ log_R_d_k = DUMMY_VAR__;
    current_statement__ = 37;
    log_R_d_k = stan::math::log(((R * (1 - mutation_proba)) / k));
    local_scalar_t__ log_one_p_R_d_k = DUMMY_VAR__;
    current_statement__ = 38;
    log_one_p_R_d_k = stan::math::log((1 + ((R * (1 - mutation_proba)) / k)));
    local_scalar_t__ log_detection_proba = DUMMY_VAR__;
    local_scalar_t__ log_1_m_detection_proba = DUMMY_VAR__;
    local_scalar_t__ log_proba_detect_ident_seq_tree_size_bigger_zero =
      DUMMY_VAR__;
    current_statement__ = 42;
    stan::math::validate_non_negative_index("log_sums",
      "upper_limit_size_identical_sequence_clusters",
      upper_limit_size_identical_sequence_clusters);
    std::vector<local_scalar_t__> log_sums =
      std::vector<local_scalar_t__>(upper_limit_size_identical_sequence_clusters,
        DUMMY_VAR__);
    current_statement__ = 43;
    stan::model::assign(log_sums,
      stan::math::rep_array(0.0, upper_limit_size_identical_sequence_clusters),
      "assigning variable log_sums");
    current_statement__ = 44;
    stan::math::validate_non_negative_index("result_temp",
      "upper_limit_size_identical_sequence_clusters",
      upper_limit_size_identical_sequence_clusters);
    std::vector<local_scalar_t__> result_temp =
      std::vector<local_scalar_t__>(upper_limit_size_identical_sequence_clusters,
        DUMMY_VAR__);
    current_statement__ = 45;
    stan::model::assign(result_temp,
      stan::math::rep_array(-10000.0,
        upper_limit_size_identical_sequence_clusters),
      "assigning variable result_temp");
    current_statement__ = 46;
    stan::math::validate_non_negative_index(
      "distribution_size_ident_seq_tree",
      "upper_limit_size_identical_sequence_clusters",
      upper_limit_size_identical_sequence_clusters);
    std::vector<local_scalar_t__> distribution_size_ident_seq_tree =
      std::vector<local_scalar_t__>(upper_limit_size_identical_sequence_clusters,
        DUMMY_VAR__);
    current_statement__ = 47;
    stan::model::assign(distribution_size_ident_seq_tree,
      stan::math::rep_array(-10000.0,
        upper_limit_size_identical_sequence_clusters),
      "assigning variable distribution_size_ident_seq_tree");
    current_statement__ = 48;
    stan::math::validate_non_negative_index(
      "distribution_size_ident_seq_tree_detection_0", "n_clusters_size + 1",
      (n_clusters_size + 1));
    std::vector<local_scalar_t__>
      distribution_size_ident_seq_tree_detection_0 =
      std::vector<local_scalar_t__>((n_clusters_size + 1), DUMMY_VAR__);
    current_statement__ = 49;
    stan::model::assign(distribution_size_ident_seq_tree_detection_0,
      stan::math::rep_array(-10000.0, (n_clusters_size + 1)),
      "assigning variable distribution_size_ident_seq_tree_detection_0");
    current_statement__ = 50;
    stan::math::validate_non_negative_index(
      "distribution_size_ident_seq_tree_detection", "n_clusters_size",
      n_clusters_size);
    std::vector<local_scalar_t__>
      distribution_size_ident_seq_tree_detection =
      std::vector<local_scalar_t__>(n_clusters_size, DUMMY_VAR__);
    current_statement__ = 51;
    stan::model::assign(distribution_size_ident_seq_tree_detection,
      stan::math::rep_array(-10000.0, n_clusters_size),
      "assigning variable distribution_size_ident_seq_tree_detection");
    current_statement__ = 52;
    stan::math::validate_non_negative_index("likelihood", "n_clusters_size",
      n_clusters_size);
    std::vector<local_scalar_t__> likelihood =
      std::vector<local_scalar_t__>(n_clusters_size, DUMMY_VAR__);
    current_statement__ = 53;
    stan::model::assign(likelihood,
      stan::math::rep_array(-10000.0, n_clusters_size),
      "assigning variable likelihood");
    current_statement__ = 56;
    for (int ii = 1; ii <= upper_limit_size_identical_sequence_clusters; ++ii) {
      current_statement__ = 54;
      stan::model::assign(distribution_size_ident_seq_tree,
        ((((stan::math::lgamma((((k * ii) + ii) - 1)) -
        stan::math::lgamma((k * ii))) - stan::math::lgamma((ii + 1))) + ((ii
        - 1) * log_R_d_k)) - ((((k * ii) + ii) - 1) * log_one_p_R_d_k)),
        "assigning variable distribution_size_ident_seq_tree",
        stan::model::index_uni(ii));
    }
    current_statement__ = 77;
    if (stan::math::logical_eq(detection_proba, 1.0)) {
      current_statement__ = 75;
      for (int ii = 1; ii <= n_clusters_size; ++ii) {
        current_statement__ = 74;
        stan::model::assign(distribution_size_ident_seq_tree_detection,
          stan::model::rvalue(distribution_size_ident_seq_tree,
            "distribution_size_ident_seq_tree",
            stan::model::index_uni(
              stan::model::rvalue(clusters_size, "clusters_size",
                stan::model::index_uni(ii)))),
          "assigning variable distribution_size_ident_seq_tree_detection",
          stan::model::index_uni(ii));
      }
    } else {
      current_statement__ = 57;
      log_detection_proba = stan::math::log(detection_proba);
      current_statement__ = 58;
      log_1_m_detection_proba = stan::math::log((1 - detection_proba));
      current_statement__ = 60;
      for (int ii = 2; ii <=
           upper_limit_size_identical_sequence_clusters; ++ii) {
        current_statement__ = 59;
        stan::model::assign(log_sums,
          (stan::model::rvalue(log_sums, "log_sums",
             stan::model::index_uni(ii)) +
          (stan::model::rvalue(log_sums, "log_sums",
             stan::model::index_uni((ii - 1))) + stan::math::log(ii))),
          "assigning variable log_sums", stan::model::index_uni(ii));
      }
      current_statement__ = 62;
      for (int ii = 1; ii <=
           upper_limit_size_identical_sequence_clusters; ++ii) {
        current_statement__ = 61;
        stan::model::assign(result_temp, ((ii * log_1_m_detection_proba) +
          stan::model::rvalue(distribution_size_ident_seq_tree,
            "distribution_size_ident_seq_tree", stan::model::index_uni(ii))),
          "assigning variable result_temp", stan::model::index_uni(ii));
      }
      current_statement__ = 63;
      stan::model::assign(distribution_size_ident_seq_tree_detection_0,
        stan::math::log_sum_exp(result_temp),
        "assigning variable distribution_size_ident_seq_tree_detection_0",
        stan::model::index_uni(1));
      current_statement__ = 64;
      for (int sym1__ = 1; sym1__ <=
           stan::math::size(clusters_size); ++sym1__) {
        int jj;
        current_statement__ = 64;
        jj = clusters_size[(sym1__ - 1)];
        current_statement__ = 65;
        stan::model::assign(result_temp,
          stan::math::rep_array(-10000.0,
            upper_limit_size_identical_sequence_clusters),
          "assigning variable result_temp");
        current_statement__ = 67;
        for (int ii = jj; ii <=
             upper_limit_size_identical_sequence_clusters; ++ii) {
          current_statement__ = 66;
          stan::model::assign(result_temp,
            (((((stan::model::rvalue(log_sums, "log_sums",
                   stan::model::index_uni(ii)) -
            stan::model::rvalue(log_sums, "log_sums",
              stan::model::index_uni(jj))) -
            stan::model::rvalue(log_sums, "log_sums",
              stan::model::index_uni(stan::math::max((ii - jj), 1)))) + (jj *
            log_detection_proba)) + ((ii - jj) * log_1_m_detection_proba)) +
            stan::model::rvalue(distribution_size_ident_seq_tree,
              "distribution_size_ident_seq_tree", stan::model::index_uni(ii))),
            "assigning variable result_temp", stan::model::index_uni(ii));
        }
        current_statement__ = 68;
        stan::model::assign(distribution_size_ident_seq_tree_detection_0,
          stan::math::log_sum_exp(
            stan::math::tail(result_temp,
              ((upper_limit_size_identical_sequence_clusters - jj) + 1))),
          "assigning variable distribution_size_ident_seq_tree_detection_0",
          stan::model::index_uni(index));
        current_statement__ = 69;
        index = (index + 1);
      }
      current_statement__ = 70;
      log_proba_detect_ident_seq_tree_size_bigger_zero = stan::math::log((1 -
                                                           stan::math::exp(
                                                             stan::model::rvalue(
                                                               distribution_size_ident_seq_tree_detection_0,
                                                               "distribution_size_ident_seq_tree_detection_0",
                                                               stan::model::index_uni(
                                                                 1)))));
      current_statement__ = 72;
      for (int ii = 1; ii <= n_clusters_size; ++ii) {
        current_statement__ = 71;
        stan::model::assign(distribution_size_ident_seq_tree_detection,
          (stan::model::rvalue(distribution_size_ident_seq_tree_detection_0,
             "distribution_size_ident_seq_tree_detection_0",
             stan::model::index_uni((ii + 1))) -
          log_proba_detect_ident_seq_tree_size_bigger_zero),
          "assigning variable distribution_size_ident_seq_tree_detection",
          stan::model::index_uni(ii));
      }
    }
    current_statement__ = 80;
    for (int ii = 1; ii <= n_clusters_size; ++ii) {
      current_statement__ = 78;
      stan::model::assign(likelihood,
        (stan::model::rvalue(clusters_freq, "clusters_freq",
           stan::model::index_uni(ii)) *
        stan::model::rvalue(distribution_size_ident_seq_tree_detection,
          "distribution_size_ident_seq_tree_detection",
          stan::model::index_uni(ii))), "assigning variable likelihood",
        stan::model::index_uni(ii));
    }
    current_statement__ = 81;
    return stan::math::sum(likelihood);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
#include <stan_meta_header.hpp>
class model_estRodis_stan_model_estimate_parameters_three final : public 
 model_base_crtp<model_estRodis_stan_model_estimate_parameters_three> {
private:
  int M;
  std::vector<int> clusters_size;
  std::vector<int> clusters_freq;
  std::vector<double> prior_r;
  std::vector<double> prior_k;
  double mutation_proba;
  std::vector<double> prior_testing;
  double sequencing_proba;
public:
  ~model_estRodis_stan_model_estimate_parameters_three() {}
  model_estRodis_stan_model_estimate_parameters_three(stan::io::var_context&
                                                      context__, unsigned int
                                                      random_seed__ = 0,
                                                      std::ostream*
                                                      pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "model_estRodis_stan_model_estimate_parameters_three_namespace::model_estRodis_stan_model_estimate_parameters_three";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 9;
      context__.validate_dims("data initialization", "M", "int",
        std::vector<size_t>{});
      M = std::numeric_limits<int>::min();
      current_statement__ = 9;
      M = context__.vals_i("M")[(1 - 1)];
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "M", M, 1);
      current_statement__ = 10;
      stan::math::validate_non_negative_index("clusters_size", "M", M);
      current_statement__ = 11;
      context__.validate_dims("data initialization", "clusters_size", "int",
        std::vector<size_t>{static_cast<size_t>(M)});
      clusters_size = std::vector<int>(M, std::numeric_limits<int>::min());
      current_statement__ = 11;
      clusters_size = context__.vals_i("clusters_size");
      current_statement__ = 12;
      stan::math::validate_non_negative_index("clusters_freq", "M", M);
      current_statement__ = 13;
      context__.validate_dims("data initialization", "clusters_freq", "int",
        std::vector<size_t>{static_cast<size_t>(M)});
      clusters_freq = std::vector<int>(M, std::numeric_limits<int>::min());
      current_statement__ = 13;
      clusters_freq = context__.vals_i("clusters_freq");
      current_statement__ = 14;
      context__.validate_dims("data initialization", "prior_r", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      prior_r = std::vector<double>(2,
                  std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      prior_r = context__.vals_r("prior_r");
      current_statement__ = 15;
      context__.validate_dims("data initialization", "prior_k", "double",
        std::vector<size_t>{static_cast<size_t>(2)});
      prior_k = std::vector<double>(2,
                  std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      prior_k = context__.vals_r("prior_k");
      current_statement__ = 16;
      context__.validate_dims("data initialization", "mutation_proba",
        "double", std::vector<size_t>{});
      mutation_proba = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 16;
      mutation_proba = context__.vals_r("mutation_proba")[(1 - 1)];
      current_statement__ = 17;
      context__.validate_dims("data initialization", "prior_testing",
        "double", std::vector<size_t>{static_cast<size_t>(4)});
      prior_testing = std::vector<double>(4,
                        std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      prior_testing = context__.vals_r("prior_testing");
      current_statement__ = 18;
      context__.validate_dims("data initialization", "sequencing_proba",
        "double", std::vector<size_t>{});
      sequencing_proba = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 18;
      sequencing_proba = context__.vals_r("sequencing_proba")[(1 - 1)];
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1;
  }
  inline std::string model_name() const final {
    return "model_estRodis_stan_model_estimate_parameters_three";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
             "stancflags = --allow-undefined"};
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "model_estRodis_stan_model_estimate_parameters_three_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ R = DUMMY_VAR__;
      current_statement__ = 1;
      R = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      local_scalar_t__ k = DUMMY_VAR__;
      current_statement__ = 2;
      k = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      local_scalar_t__ testing_proba = DUMMY_VAR__;
      current_statement__ = 3;
      testing_proba = in__.template read_constrain_lub<local_scalar_t__,
                        jacobian__>(stan::model::rvalue(prior_testing,
                                      "prior_testing",
                                      stan::model::index_uni(3)),
                        stan::model::rvalue(prior_testing, "prior_testing",
                          stan::model::index_uni(4)), lp__);
      local_scalar_t__ detection_proba = DUMMY_VAR__;
      current_statement__ = 4;
      detection_proba = (testing_proba * sequencing_proba);
      {
        current_statement__ = 5;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(R,
                         stan::model::rvalue(prior_r, "prior_r",
                           stan::model::index_uni(1)),
                         stan::model::rvalue(prior_r, "prior_r",
                           stan::model::index_uni(2))));
        current_statement__ = 6;
        lp_accum__.add(stan::math::gamma_lpdf<propto__>(k,
                         stan::model::rvalue(prior_k, "prior_k",
                           stan::model::index_uni(1)),
                         stan::model::rvalue(prior_k, "prior_k",
                           stan::model::index_uni(2))));
        current_statement__ = 7;
        lp_accum__.add(estRodis_stan_scaled_beta_lpdf<propto__>(
                         testing_proba,
                         stan::model::rvalue(prior_testing, "prior_testing",
                           stan::model::index_uni(1)),
                         stan::model::rvalue(prior_testing, "prior_testing",
                           stan::model::index_uni(2)),
                         stan::model::rvalue(prior_testing, "prior_testing",
                           stan::model::index_uni(3)),
                         stan::model::rvalue(prior_testing, "prior_testing",
                           stan::model::index_uni(4)), pstream__));
        current_statement__ = 8;
        lp_accum__.add(estRodis_stan_likelihood_log<false>(clusters_size,
                         clusters_freq, R, k, mutation_proba,
                         detection_proba, pstream__));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    static constexpr const char* function__ =
      "model_estRodis_stan_model_estimate_parameters_three_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double R = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      R = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      double k = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      k = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
            lp__);
      double testing_proba = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      testing_proba = in__.template read_constrain_lub<local_scalar_t__,
                        jacobian__>(stan::model::rvalue(prior_testing,
                                      "prior_testing",
                                      stan::model::index_uni(3)),
                        stan::model::rvalue(prior_testing, "prior_testing",
                          stan::model::index_uni(4)), lp__);
      double detection_proba = std::numeric_limits<double>::quiet_NaN();
      out__.write(R);
      out__.write(k);
      out__.write(testing_proba);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 4;
      detection_proba = (testing_proba * sequencing_proba);
      if (emit_transformed_parameters__) {
        out__.write(detection_proba);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ R = DUMMY_VAR__;
      current_statement__ = 1;
      R = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, R);
      local_scalar_t__ k = DUMMY_VAR__;
      current_statement__ = 2;
      k = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, k);
      local_scalar_t__ testing_proba = DUMMY_VAR__;
      current_statement__ = 3;
      testing_proba = in__.read<local_scalar_t__>();
      out__.write_free_lub(stan::model::rvalue(prior_testing,
                             "prior_testing", stan::model::index_uni(3)),
        stan::model::rvalue(prior_testing, "prior_testing",
          stan::model::index_uni(4)), testing_proba);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "R", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "k", "double",
        std::vector<size_t>{});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "testing_proba",
        "double", std::vector<size_t>{});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ R = DUMMY_VAR__;
      current_statement__ = 1;
      R = context__.vals_r("R")[(1 - 1)];
      out__.write_free_lb(0, R);
      local_scalar_t__ k = DUMMY_VAR__;
      current_statement__ = 2;
      k = context__.vals_r("k")[(1 - 1)];
      out__.write_free_lb(0, k);
      local_scalar_t__ testing_proba = DUMMY_VAR__;
      current_statement__ = 3;
      testing_proba = context__.vals_r("testing_proba")[(1 - 1)];
      out__.write_free_lub(stan::model::rvalue(prior_testing,
                             "prior_testing", stan::model::index_uni(3)),
        stan::model::rvalue(prior_testing, "prior_testing",
          stan::model::index_uni(4)), testing_proba);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"R", "k", "testing_proba"};
    if (emit_transformed_parameters__) {
      std::vector<std::string> temp{"detection_proba"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{}, std::vector<size_t>{}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>> temp{std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "R");
    param_names__.emplace_back(std::string() + "k");
    param_names__.emplace_back(std::string() + "testing_proba");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "detection_proba");
    }
    if (emit_generated_quantities__) {}
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "R");
    param_names__.emplace_back(std::string() + "k");
    param_names__.emplace_back(std::string() + "testing_proba");
    if (emit_transformed_parameters__) {
      param_names__.emplace_back(std::string() + "detection_proba");
    }
    if (emit_generated_quantities__) {}
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"R\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"k\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"testing_proba\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"detection_proba\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"R\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"k\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"testing_proba\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"detection_proba\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((1 + 1) + 1);
    const size_t num_transformed = emit_transformed_parameters * (1);
    const size_t num_gen_quantities = emit_generated_quantities * (0);
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = model_estRodis_stan_model_estimate_parameters_three_namespace::model_estRodis_stan_model_estimate_parameters_three;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_estRodis_stan_model_estimate_parameters_three_namespace::profiles__;
}
#endif
#endif
